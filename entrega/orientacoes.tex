\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[margin=2.5cm]{geometry}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage[hidelinks]{hyperref}

% Configuração de cores
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configuração do listings para Python
\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=pythonstyle}

\title{\textbf{Orientações para Entrega do Código}\\[0.5cm]
\large ELE634 -- Laboratório de Sistemas II}
\author{André Costa Batista}
\date{\today}

\begin{document}

\maketitle

\section{Introdução}

Este documento estabelece o padrão que deve ser seguido por todos os grupos para a entrega da implementação de seus algoritmos de otimização. O objetivo é garantir que todas as implementações possam ser executadas de forma padronizada e comparadas adequadamente.

\section{Critério de Parada}

O critério de parada adotado para todos os algoritmos será o \textbf{número de avaliações da função objetivo}. Isso garante uma comparação justa entre diferentes abordagens. Uma avaliação da função objetivo é uma execução da função do seu código que calcula o valor da função objetivo para uma solução candidata. Então, toda vez que seu código chamar essa função, deve ser contado como uma avaliação. O algoritmo deve parar quando atingir o número máximo de avaliações especificado e retornar a melhor solução encontrada até então. Eu vou ler o código das implementações para verificar se esse critério está sendo respeitado corretamente.

Quem for utilizar o Gurobi como forma de busca local, deve somar ao número de avaliações os seguintes parâmetros do objeto de modelo do Gurobi: \texttt{NodeCount} e \texttt{IterCount}. Para controlar uma execução do Gurobi de modo que respeite um número máximo para esses parâmetros, você pode utilizar o seguinte código:
\begin{lstlisting}[language=Python]
from gurobipy import Model, GRB
model = Model()

# Configurar o modelo aqui

# Definir limites maximos
model.setParam(GRB.Param.NodeLimit, max_node_count)
model.setParam(GRB.Param.IterationLimit, max_iter_count)

# Otimizar
model.optimize()

# Apos a otimizacao, recuperar os valores usados
nos_explorados = modelo.NodeCount
iteracoes_usadas = modelo.IterCount

# Calcular total de avaliacoes equivalentes
total_avaliacoes = nos_explorados + iteracoes_usadas
\end{lstlisting}

\section{Estrutura da Entrega}

\subsection{Formato do Arquivo}

\begin{enumerate}[label=\arabic*.]
    \item Cada grupo deve entregar sua implementação em uma \textbf{pasta zipada}.
    
    \item O arquivo ZIP deve ter o nome do grupo, por exemplo: \texttt{reginaldorossi.zip}

    \item Dentro da pasta descompactada, deve existir um arquivo Python com o \textbf{nome do grupo}, por exemplo: \texttt{reginaldorossi.py}

    \item Este arquivo principal deve conter um método chamado \texttt{\textbf{resolva}} que executa o algoritmo implementado.
    
    \item A pasta pode conter outros arquivos auxiliares (módulos, classes, funções auxiliares, etc.), mas a \textbf{interface de execução} será sempre o método \texttt{resolva} do arquivo principal.
\end{enumerate}

\subsection{Exemplo de Estrutura}

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Estrutura de Diretórios]
\begin{verbatim}
reginaldorossi.zip
|-- reginaldorossi.py        # Arquivo principal (obrigatorio)
|-- heuristicas.py           # Modulo auxiliar (opcional)
|-- operadores.py            # Modulo auxiliar (opcional)
|-- utils.py                 # Utilitarios (opcional)
`-- README.md                # Opcional
\end{verbatim}
\end{tcolorbox}

\section{Especificação do Método \texttt{resolva}}

\subsection{Assinatura da Função}

O método \texttt{resolva} deve ter a seguinte assinatura:

\begin{lstlisting}[language=Python]
def resolva(dados: Dados, numero_avaliacoes: int) -> Solucao:
    """
    Executa o algoritmo de otimizacao.
    
    Parametros:
    -----------
    dados : Dados
        Objeto contendo os dados da instancia do problema
        (requisicoes, onibus, janelas de tempo, etc.)
    
    numero_avaliacoes : int
        Numero maximo de avaliacoes da funcao objetivo permitidas
    
    Retorna:
    --------
    Solucao
        Objeto contendo:
        - Rotas de cada viagem de cada onibus
        - Instante de chegada de cada requisicao
        - Valor da funcao objetivo
    """
    # Implementacao do algoritmo aqui
    pass
\end{lstlisting}

\subsection{Parâmetros de Entrada}

\begin{description}[leftmargin=3cm,style=nextline]
    \item[\texttt{dados}] Objeto da classe \texttt{Dados}\footnote{A mesma que está presente no arquivo \texttt{dados.py} no repositório da disciplina.} contendo todos os parâmetro de uma determinada instância do problema, conforme estão a modelagem.
    \item[\texttt{numero\_avaliacoes}] Valor inteiro que define o critério de parada. O algoritmo deve parar quando atingir este número de avaliações da função objetivo.
\end{description}

\subsection{Valor de Retorno}

O método deve retornar um objeto da classe \texttt{Solucao}\footnote{A mesma que está no arquivo \texttt{solucao.py} do repositório da disciplina.} contendo:

\begin{itemize}
    \item \textbf{Rotas}: Sequência de requisições atendidas por cada viagem de cada ônibus.
    \item \textbf{Tempos de chegada}: Instante em que cada ônibus chega em cada requisição de cada viagem.
    \item \textbf{Função objetivo}: Valor calculado da função objetivo.
\end{itemize}

\subsection{Estrutura dos Atributos da Classe \texttt{Solucao}}

A classe \texttt{Solucao} possui três atributos principais que devem ser preenchidos:

\begin{description}[leftmargin=3cm,style=nextline]
    \item[\texttt{rota}] Dicionário hierárquico indexado por ônibus e viagem: \texttt{rota[k][v]} retorna uma lista de requisições visitadas pelo ônibus \texttt{k} na viagem \texttt{v}. Cada rota \textbf{sempre inicia e termina na garagem} (índice 0).
    
    \item[\texttt{chegada}] Dicionário hierárquico indexado por ônibus e viagem: \texttt{chegada[k][v]} retorna uma lista de tempos (float) correspondentes aos instantes de chegada em cada ponto da rota. O primeiro elemento é sempre 0 (chegada na garagem inicial).
    
    \item[\texttt{fx}] Valor da função objetivo (float) calculado para a solução.
\end{description}

Veja a seguir um exemplo ilustrativo de como preencher esses atributos. Considere uma solução para a instância \texttt{pequena.json} com 14 requisições, 3 ônibus e até 4 viagens por ônibus:

\begin{lstlisting}[language=Python]
from solucao import Solucao

# Criar objeto de solucao
solucao = Solucao()

# Configurar rotas
# Onibus 1 realiza 3 viagens
solucao.rota[1] = {}
solucao.rota[1][1] = [0, 2, 4, 0]     # Viagem 1: garagem -> req 2 -> req 4 -> garagem
solucao.rota[1][2] = [0, 6, 8, 11, 0] # Viagem 2: garagem -> req 6 -> req 8 -> req 11 -> garagem
solucao.rota[1][3] = [0, 13, 0]       # Viagem 3: garagem -> req 13 -> garagem
solucao.rota[1][4] = []               # Viagem 4: nao utilizada

# Onibus 2 realiza 2 viagem
solucao.rota[2] = {}
solucao.rota[2][1] = [0, 3, 0]         # Viagem 1: garagem -> req 3 -> garagem
solucao.rota[2][2] = [0, 7, 9, 10, 0]  # Viagem 2: garagem -> req 7 -> req 9 -> req 10 -> garagem
solucao.rota[2][3] = []                # Viagem 3: nao utilizada
solucao.rota[2][4] = []                # Viagem 4: nao utilizada

# Onibus 3 realiza 4 viagens
solucao.rota[3] = {}
solucao.rota[3][1] = [0, 1, 0]   # Viagem 1: garagem -> req 1 -> garagem
solucao.rota[3][2] = [0, 5, 0]   # Viagem 2: garagem -> req 5 -> garagem
solucao.rota[3][3] = [0, 12, 0]  # Viagem 3: garagem -> req 12 -> garagem
solucao.rota[3][4] = [0, 14, 0]  # Viagem 4: garagem -> req 14 -> garagem

# Configurar tempos de chegada (correspondentes as rotas)
solucao.chegada[1] = {}
solucao.chegada[1][1] = [3.89, 17.0, 31.08, 80.2]          # Tempos para rota[1][1]
solucao.chegada[1][2] = [80.2, 92.0, 132.5, 185.0, 200.2]  # Tempos para rota[1][2]
solucao.chegada[1][3] = [202.12, 215.0, 223.0]             # Tempos para rota[1][3]
solucao.chegada[1][4] = []                                 # Viagem nao utilizada

solucao.chegada[2] = {}
solucao.chegada[2][1] = [13.89, 27.0, 80.2]               # Tempos para rota[2][1]
solucao.chegada[2][2] = [80.2, 92.0, 132.5, 175.0, 200.2] # Tempos para rota[2][2]
solucao.chegada[2][3] = []                                # Viagem nao utilizada
solucao.chegada[2][4] = []                               # Viagem nao utilizada

solucao.chegada[3] = {}
solucao.chegada[3][1] = [1.7, 14.81, 23.89]      # Tempos para rota[3][1]
solucao.chegada[3][2] = [23.89, 37.0, 45.97]     # Tempos para rota[3][2]
solucao.chegada[3][3] = [182.12, 195.0, 204.13]  # Tempos para rota[3][3]
solucao.chegada[3][4] = [204.13, 217.01, 224.18] # Tempos para rota[3][4]

# Configurar funcao objetivo
solucao.fx = 33486.4
\end{lstlisting}

\begin{tcolorbox}[colback=yellow!10!white,colframe=orange!75!black,title=\textbf{Pontos Importantes}]
\begin{itemize}
    \item \textbf{Índice 0 é a garagem}: Toda rota deve começar e terminar com 0
    \item \textbf{Correspondência}: O tamanho de \texttt{rota[k][v]} e \texttt{chegada[k][v]} deve ser \textbf{exatamente o mesmo}
    \item \textbf{Viagens não utilizadas}: Representadas por listas vazias \texttt{[]}
    \item \textbf{Saída da garagem (primeiro valor de chegada)}: Instante em que o ônibus começa o preparo para a viagem. Ou seja, é igual ao instante em que o ônibus chega na primeira requisição da viagem menos o tempo de deslocamento da garagem até essa requisição e menos o tempo de preparo inicial (que o tempo de serviço relativo à garagem).
    \item \textbf{Chegada na garagem (último valor de chegada)}: Instante em que o ônibus retorna à garagem após a última requisição da viagem.
    \item \textbf{Todos os ônibus e viagens}: Mesmo que não utilizados, devem ter entradas no dicionário
    \item \textbf{IMPORTANTE}: Dentro da execução do seu algoritmo, você pode utilizar a estrutura de dados que quiser. A estrutura apresentada aqui é apenas para a \textbf{saída final} do método \texttt{resolva} através do objeto \texttt{Solucao}.
\end{itemize}
\end{tcolorbox}

\subsection{Número de avaliações por instância}

A regra que vou adotar para definir o número máximo de avaliações ($N^{max}_{av}$) da função objetivo por instância é a seguinte:
\begin{equation}
    N^{max}_{av} = 10 \times n \times K \times r
\end{equation}

\noindent onde, conforme a modelagem, $n$ é o número de requisições, $K$ é o número de ônibus disponíveis, e $r$ é o número máximo de viagens que cada ônibus pode realizar. A tabela abaixo apresenta os valores de $N^{max}_{av}$ para cada instância fornecida:

\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=Número Máximo de Avaliações por Instância]
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Instância} & \textbf{n (requisições)} & \textbf{K (ônibus)} & \textbf{r (viagens/ônibus)} & \textbf{$N^{max}_{av}$} \\
\hline
pequena & 14 & 3 & 5 & 2100 \\
\hline
média & 67 & 6 & 12 & 48240 \\
\hline
grande & 108 & 11 & 10 & 118800 \\
\hline
rush & 108 & 11 & 10 & 118800 \\
\hline
\end{tabular}
\end{tcolorbox}

\section{Validação e Avaliação}

\subsection{Processo de Validação}

Após a execução de cada algoritmo, será executada uma função de validação que verificará:

\begin{enumerate}
    \item \textbf{Viabilidade da solução}: Nenhuma restrição do problema foi violada
    \item \textbf{Cálculo correto da função objetivo}: Conferência do valor reportado
\end{enumerate}

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=\textbf{Atenção}]
Uma solução final de cada execução que violar qualquer restrição será considerada \textbf{infactível} e será descartada da amostra dos resultados.
\end{tcolorbox}

\subsection{Protocolo de Execução para Comparação}

\begin{enumerate}
    \item Cada algoritmo será executado em cada instância \textbf{30 vezes}
    \item Cada chamada da função \texttt{resolva} executa o algoritmo \textbf{uma única vez}
    \item A comparação estatística entre os algoritmos será feita com base na média (ou mediana) dos valores da função objetivo obtidos nas 30 execuções (considerando apenas soluções viáveis). Gráficos de boxplot também serão apresentados.
\end{enumerate}

\section{Recomendações}

\begin{itemize}
    \item \textbf{Controle rigoroso do número de avaliações}: Certifique-se de que seu algoritmo respeita exatamente o limite especificado
    
    \item \textbf{Tratamento de erros}: Implemente tratamento adequado de exceções para evitar crashes
    
    \item \textbf{Documentação}: Comente seu código adequadamente, especialmente o método \texttt{resolva}
    
    \item \textbf{Teste local}: Teste sua implementação com as instâncias fornecidas antes da entrega
\end{itemize}

% \subsection{Exemplo de Teste Local}

% \begin{lstlisting}[language=Python]
% # Script de teste local

% from dados import Dados
% from seujorge import resolva

% # Carregar instancia
% dados = Dados.carrega_dados_json('dados/pequena.json')

% # Executar algoritmo
% numero_avaliacoes = 10000
% solucao = resolva(dados, numero_avaliacoes)

% # Verificar resultado
% print(f"Funcao objetivo: {solucao.funcao_objetivo}")
% print(f"Numero de rotas: {len(solucao.rotas)}")

% # Validar solucao
% if solucao.valida(dados):
%     print("Solucao viavel!")
% else:
%     print("Solucao inviavel - corrigir!")
% \end{lstlisting}


\end{document}
